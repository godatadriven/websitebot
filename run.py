# Generated by Selenium IDE
import pytest
import time
import pandas as pd
import json
import traceback
import sys
import time 
import os
import textwrap
import openai
from termcolor import colored
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

## added this
from selenium.webdriver.chrome.options import Options



ATTS = ['id','title','name','value']
openai.api_key = os.environ['OPENAI_API_KEY']



class WebsiteBot:
    def __init__(self, driver, goal, url):
        self.driver = driver
        self.goal = goal
        self.url = url
        self.driver.get(url)
        self.plans = [f'go to website {url}']
        # sleept to load webpage
        time.sleep(1)


    def _elem2tag(self,elem):
        '''
        Transform a Selenium element into a dict describing the corresponding tag
        '''
        tag = {
        "type": elem.tag_name,
        #"text": elem.text,
        "x": elem.location['x'],
        "y": elem.location['y'],
        "width": elem.size['width'],
        "height": elem.size['height']
        }
        if elem.text != '':
            tag['text'] = elem.text
        for att in ATTS:
            if elem.get_attribute(att) not in ('', None):
                tag[att] = elem.get_attribute(att)
        # "id": elem.get_attribute("id"),
        # #"class": elem.get_attribute("class"),
        # "title": elem.get_attribute("title"),
        # "name": elem.get_attribute("name"),
        # #"href": elem.get_attribute("href"),
        # #"font-size": elem.value_of_css_property("font-size"),
        return tag


    def extract_tags(self):
        '''
        Extract tags from current website
        '''
        print('>>> extract tags')
        tags = []
        
        # Extract anchor and button elements
        elements = self.driver.find_elements(By.CSS_SELECTOR, "a, button, input")

        # Find input elements with specific types for text entry
        input_types = ['text', 'password', 'search', 'email', 'number', 'tel', 'url']
        css_selector = ', '.join(f"input[type='{input_type}']" for input_type in input_types)
        elements.extend(self.driver.find_elements(By.CSS_SELECTOR, css_selector))

        # Get text elements
        xpath_query = "//*[self::div or self::span][normalize-space(.)]"
        elements_with_text = self.driver.find_elements(By.XPATH, xpath_query)
        elements += [ element for element in elements_with_text if element.text != '' ]

        for element in elements:
            # Do not keep invisible elements
            if not element.is_displayed():
                continue
            tag = self._elem2tag(element)
            if tag['width']==0 or tag["height"]==0:
                continue
            # Do not keep elements which have absolutely no description
            if all( not att in tag for att in ATTS+['text'] ):
                continue
            tags.append(tag)
        print('#tags extracted:',len(tags))
        return tags


    def cleanse_tags(self, tags: list, y_max=3000) -> list:
        '''
        tags is a list of dictionaries. This method removes all dicts in this list where the
        text-key is contained in the text-key of another dict. Only the dict with the longest
        text-key is kept in case there is a chain of containments.
        '''
        print('>>> cleanse tags')
        cleansed_tags = []
        
        # Sort the tags list by the length of the text-key in descending order
        tags.sort(key=lambda x: len(x['text']) if 'text' in x else 0, reverse=True)
        
        for tag in tags:
            if tag['y'] > y_max:
                continue
            if any(tag == cleansed_tag for cleansed_tag in cleansed_tags):
                continue
            # If the text-key of the current tag is not contained in the text-key of any tag in the cleansed_tags list, add it to the cleansed_tags list
            if tag['type'] not in ['button','a','input'] and any(tag['text'] in cleansed_tag['text'] for cleansed_tag in cleansed_tags):
                continue
            cleansed_tags.append(tag)

        cleansed_tags = sorted(cleansed_tags,key=lambda x: x['y'])
        print('#tags after cleansing:',len(cleansed_tags))
        return cleansed_tags


    def get_prompt(self,tags,filename='prompt.txt'):
        '''
        Compute prompt
        '''
        print('>>> get prompt')

        prompt = textwrap.dedent(f'''
        OVERALL GOAL: {self.goal}
        ''')

        newline = '\n'
        prompt += textwrap.dedent(f'''
        PREVIOUS STEPS:
        {newline.join(plan for plan in self.plans)}
        ''')

        prompt += textwrap.dedent(f'''        
        CURRENT SITUATION: after the previous steps we are now on a website that contains the following tags:\n
        ''')

        for tag in tags:
            # restrict to descriptive attributes
            tag_ = { k:v for k,v in tag.items() 
                    if k in ['type','text']+ATTS }
            prompt += json.dumps(tag_,ensure_ascii=False)+'\n'

        prompt += textwrap.dedent('''
        NEXT STEPS: which next steps should we take on this website to achieve the overall goal. 
        In case we need to accept cookies, do this first. Return next steps in the following json-format.
        Do not return anything else except this json-format!          

        {
            plan: '<high-level description of the website, the next steps on this website and a summary of the expected result>',
            steps: [<step1>,<step2>,...],
        }
                
        The steps-attribute should contain a list of steps to execute on this website. 
        A <step> can have the following dict-structures:       
        {"action":"click","tag":<tag>} for a <tag> of type button or a
        ("action":"fill","value":<value_to_fill>,"tag":<tag>} for a <tag> of type input
        ''')

        open(filename,'w').write('')
        with open(filename,'a',encoding='utf-8') as file:
            file.write(prompt)
        
        return prompt
    

    def run_prompt(self,prompt):
        print('>>> run prompt')
        print(colored(prompt, 'green'))

        response = openai.ChatCompletion.create(
        model = 'gpt-4',
        #model = 'gpt-3.5-turbo',
        #prompt=prompt,
        messages = [{"role": "user", "content": prompt}],
        temperature=1,
        max_tokens=1000,
        top_p=1.0,
        frequency_penalty=0.0,
        presence_penalty=0.0
        )
        plan = response['choices'][0]['message']['content']
        start = plan.index('{')
        end = plan.rindex('}') + 1  # Adding 1 because slicing is end-exclusive
        plan = json.loads(plan[start:end])
        print(colored(json.dumps(plan,indent=1), 'light_blue'))
        return plan
    

    def _get_element(self,driver,tag):
        '''
        tag is a dictionary which describes an html tag:
        tag: the type of the tag
        text: the text contained in the tag
        all other keys correspond to tag attributes.
        This method returns the element in driver that corresponds to this tag
        '''
        
        # Construct xpath query to find the element
        xpath_query = f"//{tag['type']}"

        if 'id' in tag:
            xpath_query += f"[@id='{tag['id']}']"
        elif 'text' in tag:
            xpath_query += f"[normalize-space(.)='{tag['text']}']"
        else:
            print('element description not found')
            return
        print('xpath-query:',xpath_query)
        element = driver.find_element(By.XPATH, xpath_query)
        
        # Add attributes to the xpath query
        # for att, value in tag.items():
        #     if att not in ['type','text']:
        #         xpath_query += f"[@{att}='{value}']"
        #breakpoint()
        #time.sleep(1)
        return element


    def execute_steps(self,steps):
        print('#steps to execute:',len(steps))
        for step in steps:
            time.sleep(1)
            tag = step['tag']
            for _ in range(10):
                try:
                    if step['action'] == 'click':
                        print('click:',tag)
                        element = self._get_element(driver,tag)
                        element.click()
                    elif step['action'] == 'fill':
                        print(f"fill with value {step['value']}:",tag)
                        element = self._get_element(driver,tag)
                        element.clear()
                        element.send_keys(step['value'])
                    # Find the body or html element (covers the entire page)
                    body_element = driver.find_element(By.TAG_NAME, "body")
                    actions = ActionChains(driver)
                    actions.move_to_element_with_offset(body_element, 0, 0).click()
                    break
                except:
                    print('sth went wrong with element')
                    traceback.print_exc()
            time.sleep(1)


    def run(self):
        while True:   
            tags = self.extract_tags()
            tags = self.cleanse_tags(tags)
            prompt = self.get_prompt(tags)
            plan = self.run_prompt(prompt)
            self.plans.append(plan['plan'])
            steps = plan['steps']
            self.execute_steps(steps)
            time.sleep(1)
            print(colored('=========> next round','light_red'))



            


url = 'https://shop.sbb.ch/de/kaufen/pages/fahrplan/fahrplan.xhtml'
goal = 'book a train ticket from Zurich to Bern on October 1st around 4pm'

print(colored('GOAL:','light_red'), goal)
print(colored('URL:','light_red'), url)
print('                ')


chrome_options = Options()
chrome_options.add_argument("--headless --window-size=2000,1000 --blink-settings=imagesEnabled=false")
#chrome_options.add_argument("--headless")
driver = webdriver.Chrome(chrome_options)



bot = WebsiteBot(driver,goal,url)
bot.run()

driver.close()








#url = 'https://www.cnet.com/tech/tech-industry/marc-benioffs-teenage-affair-with-the-macintosh/'
#url = 'https://www.homegate.ch/en'
#url = 'https://www.sbb.ch'
# wait so that everything is loaded


# tags = extract_tags(driver)
# tags = cleanse_tags(tags)
# write_prompt(tags)
# sys.exit(0)


# plan = '''
# {
#     "plan": "We'll start by accepting cookies for optimal site function, then proceed to fill in the departure and destination details and search for the connections available from Zurich to Bern on October 1st.",
#     "steps": [
#         {"action": "click", "tag": {"type": "button", "text": "Akzeptieren", "id": "onetrust-accept-btn-handler"}},
#         {"action": "fill", "value": "Zurich", "tag": {"type": "input", "id": "shopForm_von_valueComp", "name": "shopForm_von_valueComp"}},
#         {"action": "fill", "value": "Bern", "tag": {"type": "input", "id": "shopForm_nach_valueComp", "name": "shopForm_nach_valueComp"}},
#         {"action": "fill", "value": "01.10.2023", "tag": {"type": "input", "id": "shopForm_datepicker_valueComp", "name": "shopForm_datepicker_valueComp"}},
#         {"action": "click", "tag": {"type": "button", "text": "Verbindung suchen"}}
#     ]
# }
# '''
# plan = json.loads(plan)

# execute_steps(plan['steps'])


# 


        














